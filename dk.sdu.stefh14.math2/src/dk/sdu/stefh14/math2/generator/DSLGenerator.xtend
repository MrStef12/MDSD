/*
 * generated by Xtext 2.13.0
 */
package dk.sdu.stefh14.math2.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.stefh14.math2.dSL.MathExp
import dk.sdu.stefh14.math2.dSL.Expression
import dk.sdu.stefh14.math2.dSL.Plus
import dk.sdu.stefh14.math2.dSL.Minus
import dk.sdu.stefh14.math2.dSL.Mult
import dk.sdu.stefh14.math2.dSL.Div
import dk.sdu.stefh14.math2.dSL.Num
import dk.sdu.stefh14.math2.dSL.Var
import dk.sdu.stefh14.math2.dSL.Let
import java.util.Map
import java.util.HashMap
import dk.sdu.stefh14.math2.dSL.ExternalDef
import dk.sdu.stefh14.math2.dSL.ExternalUse
import dk.sdu.stefh14.math2.dSL.Parameter
import dk.sdu.stefh14.math2.dSL.MathModel
import org.eclipse.emf.common.util.EList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DSLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var math = resource.allContents.filter(MathModel).next
		fsa.generateFile("MathComputation.java", math.compile);
	}
	
/*
 * override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		System.out.println("Math expression = "+math.display)
		JOptionPane.showMessageDialog(null, "result = "+result,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
 */
 	
 	def compile(MathModel model) '''public class MathComputation {
 		«IF model.externalDefs.length > 0»
 		«model.externalDefs.compileInterface»
 		private Externals externals;
 		public MathComputation(Externals _externals) {
 			externals = _externals;
 		}
 		«ENDIF»
 		public void compute() {
 			«FOR exp : model.mathExps»
 			«exp.compileExp»
 			«ENDFOR»
 		}
 	}'''
 	
 	def compileInterface(EList<ExternalDef> extDefs)
 	'''public static interface Externals {
 		«FOR extDef : extDefs»
 		public «extDef.displayExt»;
 		«ENDFOR»
 	}'''
 	
 	def compileExp(MathExp exp) 
 	'''System.out.println("«exp.id» "+«exp.exp.displayExp»)'''
	
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def int compute(MathExp math) { 
		math.exp.computeExp(new HashMap<String,Integer>)
	}
	
	def int computeExp(Expression exp, Map<String,Integer> env) {
		switch exp {
			Plus: exp.left.computeExp(env)+exp.right.computeExp(env)
			Minus: exp.left.computeExp(env)-exp.right.computeExp(env)
			Mult: exp.left.computeExp(env)*exp.right.computeExp(env)
			Div: exp.left.computeExp(env)/exp.right.computeExp(env)
			Num: exp.value
			Var: env.get(exp.id)
			Let: exp.body.computeExp(env.bind(exp.id,exp.binding.computeExp(env)))
			default: throw new Error("Invalid expression")
		}
	}
	
	def Map<String, Integer> bind(Map<String, Integer> env1, String name, int value) {
		val env2 = new HashMap<String,Integer>(env1)
		env2.put(name,value)
		env2 
	}

	//
	// Display function: show complete syntax tree
	// Note: written according to illegal left-recursive grammar, requires fix
	//

	def String display(MathExp math) { 
		math.exp.displayExp
	}
	
	def String displayExp(Expression exp) {
		"("+switch exp {
			Plus: exp.left.displayExp+"+"+exp.right.displayExp
			Minus: exp.left.displayExp+"-"+exp.right.displayExp
			Mult: exp.left.displayExp+"*"+exp.right.displayExp
			Div: exp.left.displayExp+"/"+exp.right.displayExp
			Num: Integer.toString(exp.value)
			Var: exp.id
			Let: '''let «exp.id» = «exp.binding.displayExp» in «exp.body.displayExp» end'''
			ExternalUse: exp.displayExternalUse
			default: throw new Error("Invalid expression")
		}+")"
	}
	
	def displayExternalUse(ExternalUse extUse)
	'''externals.«extUse.external.name»(«FOR arg : extUse.arguments SEPARATOR ", "»«arg»«ENDFOR»)'''
	
	def displayExt(ExternalDef extDef)
	'''«extDef.returnType» «extDef.name»(«FOR p : extDef.parameters SEPARATOR ", "»«p.displayParam»«ENDFOR»)''' 
	
	def displayParam(Parameter param)
	'''«param.type» «param.varName»'''
}
